--- src/plugins/multimedia/ffmpeg/qavfcamera.mm.orig	2024-12-11 00:35:23.000000000 +0100
+++ src/plugins/multimedia/ffmpeg/qavfcamera.mm	2024-12-11 00:42:22.000000000 +0100
@@ -329,8 +329,10 @@
         [m_videoDataOutput connectionWithMediaType:AVMediaTypeVideo] :
         nullptr;
     if (connection) {
+#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 140000
         if (@available(macOS 14.0, iOS 17.0, *))
             connectionAngle = static_cast<int>(std::round(connection.videoRotationAngle));
+#endif
 
         transform.mirrorredHorizontallyAfterRotation = connection.videoMirrored;
     }
@@ -353,6 +355,7 @@
     // or start listening for UIDeviceOrientation changes.
     if (isActive()) {
         // Use RotationCoordinator if we can.
+#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 140000
         if (@available(macOS 14.0, iOS 17.0, *)) {
             if (m_rotationCoordinator)
                 [m_rotationCoordinator release];
@@ -367,6 +370,7 @@
                     previewLayer:nil];
             }
         }
+#endif
 #ifdef Q_OS_IOS
         else {
             // If we're running iOS 16 or older, we need to register for UIDeviceOrientation changes.
@@ -403,6 +407,7 @@
         return 0;
 #endif
 
+#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 140000
     if (@available(macOS 14.0, iOS 17.0, *)) {
         // This code assumes that AVCaptureDeviceRotationCoordinator.videoRotationAngleForHorizonLevelCapture
         // returns degrees that are divisible by 90. This has been the case during testing.
@@ -415,6 +420,7 @@
             return static_cast<int>(std::round(
                 m_rotationCoordinator.videoRotationAngleForHorizonLevelCapture));
     }
+#endif
 #ifdef Q_OS_IOS
     else {
         AVCaptureDevice *captureDevice = device();
